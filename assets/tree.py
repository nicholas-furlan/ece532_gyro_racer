import os
import fnmatch

# Replace with your project path
root = "."
output_file = "tree.txt"

# Add patterns to exclude (supports wildcards)
exclude_patterns = [
    '.git',
    '.gitignore',
    '.DS_Store',
    '__pycache__',
    '*.pyc',
    '*.pyo',
    '*.pyd',
    '*.so',
    '*.dll',
    '*.dylib',
    '*.log',
    '*.jou',
    '*.str',
    '*.zip',
    '*.debug',
    '*.backup.*',
    '.metadata',
    'Debug',
    'Release',
    '.settings',
    '*.o',
    '*.d',
    '*.elf',
    '*.bin',
    '*.map',
    '*.out',
    'RemoteSystemsTempFiles',
    'SDK.log',
    'webtalk',
    'standalone*',
    'bsplib',
    'lib',
    '.runs',
    '.cache',
    '.hw',
    '.Xil',
    '.gen',
    '.gitmodules',
]

# Add specific paths to include but skip their contents
# Use relative paths from the root directory with wildcards
# The value is the comment to show, or None/empty string for default [contents skipped]
include_dir_skip_contents = {
    '**/bd/design_1': 'block design <design_1> files',
    '**/bd/mref': 'block design reference files',
    '*.ip_user_files': 'IP user files generated by Vivado',
    'ip/ip_repo/gyro_reader_1.0': 'IP repository files for custom IP',
    'ip/managed_ip_project': 'managed IP project files',
    'ip_keyboard/axi_ps2_1.0': 'IP repository files for digilent PS/2 IP',
    'assets/output': 'Header files generated from images',
    'assets/resource': 'Images for characters/tracks/fonts',
    'docs': 'Documentation of the project',
    'stash': 'Temporary files during development',
    '**/memory/tlsf': 'An referenced open-source implementation of memory pool'
}

def should_exclude(name):
    return any(fnmatch.fnmatch(name, pattern) for pattern in exclude_patterns)

def should_skip_contents(path):
    # Convert path to relative path from root
    rel_path = os.path.relpath(path, root)
    # Normalize path separators to forward slashes
    rel_path = rel_path.replace('\\', '/')

    # Check if the full path matches any pattern
    for pattern in include_dir_skip_contents:
        if fnmatch.fnmatch(rel_path, pattern):
            return True
    return False

def get_skip_comment(path):
    # Convert path to relative path from root
    rel_path = os.path.relpath(path, root)
    # Normalize path separators to forward slashes
    rel_path = rel_path.replace('\\', '/')

    # Find the matching pattern and its comment
    for pattern, comment in include_dir_skip_contents.items():
        if fnmatch.fnmatch(rel_path, pattern):
            if comment and comment.strip():
                return f"[{comment}]"
            return "[contents skipped]"
    return "[contents skipped]"

def get_single_file_path(path):
    """Recursively check if path leads to a single file, returning the full path if it does."""
    try:
        contents = [item for item in os.listdir(path) if not should_exclude(item)]
        if len(contents) == 0:
            return None
        if len(contents) > 1:
            return None

        item = contents[0]
        item_path = os.path.join(path, item)

        if os.path.isfile(item_path):
            return item
        elif os.path.isdir(item_path) and should_skip_contents(item_path):
            return item + "/ " + get_skip_comment(item_path)
        elif os.path.isdir(item_path):
            sub_path = get_single_file_path(item_path)
            if sub_path:
                return item + "/" + sub_path
    except PermissionError:
        pass
    return None

def print_tree(start_path, prefix='', current_path=''):
    tree_lines = []
    try:
        # Get all files and directories
        all_items = os.listdir(start_path)

        # Separate directories and files
        directories = []
        files = []

        for name in all_items:
            if should_exclude(name):
                continue

            path = os.path.join(start_path, name)
            if os.path.isdir(path):
                directories.append(name)
            else:
                files.append(name)

        # Sort both lists
        directories.sort()
        files.sort()

        # Process directories first
        for i, name in enumerate(directories):
            path = os.path.join(start_path, name)
            is_last = (i == len(directories) - 1 and not files)  # Last if it's the last directory and there are no files
            connector = '└── ' if is_last else '├── '

            # Build the current path for this directory
            dir_path = os.path.join(current_path, name) if current_path else name
            # Normalize path separators to forward slashes
            dir_path = dir_path.replace('\\', '/')

            if should_skip_contents(path):
                # Show skipped content directories as a single line with just the directory name
                comment = get_skip_comment(path)
                tree_lines.append(prefix + connector + name + "/ " + comment)
            else:
                # Check if directory leads to a single file
                single_file_path = get_single_file_path(path)
                if single_file_path:
                    # Compact format for single-file directories (including nested)
                    tree_lines.append(prefix + connector + name + "/" + single_file_path)
                else:
                    # Normal directory listing
                    tree_lines.append(prefix + connector + name + "/")
                    extension = '    ' if is_last else '│   '
                    tree_lines += print_tree(path, prefix + extension, dir_path)

        # Then process files
        for i, name in enumerate(files):
            is_last = (i == len(files) - 1)
            connector = '└── ' if is_last else '├── '
            tree_lines.append(prefix + connector + name)

    except PermissionError:
        return tree_lines

    return tree_lines

tree_result = print_tree(root)

with open(output_file, "w", encoding="utf-8") as f:
    f.write("\n".join(tree_result))

print(f"Tree saved to {output_file}")